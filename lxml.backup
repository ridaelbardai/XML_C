#ifndef LITTLE_XML_H
#define LITTLE_XML_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif
/**
 * PROTOTYPES
 */
// XMLNode *XMLNode_new(XMLNode *parent);
// void XMLNode_free(XMLNode *node);

// int XMLDocument_load(XMLDocument *doc, const char *path);
// void XMLDocument_free(XMLDocument *Doc);

/**
 * structures
 */

struct xmlattribute
{
    char *key;
    char *value;
};
typedef struct xmlattribute XMLAttribute;

struct xmlattributelist
{
    int heap_size;
    int size;
    XMLAttribute *data;
};
typedef struct xmlattributelist XMLAttributelist;

struct xmlnodelist
{
    int heap_size;
    int size;
    struct xmlnode **data;
};
typedef struct xmlnodelist XMLNodelist;

struct xmlnode
{
    char *tag;
    char *inner_text;
    XMLAttributelist attributes;
    XMLNodelist childrens;
    struct xmlnode *parent;
};
typedef struct xmlnode XMLNode;

struct xmldocument
{
    XMLNode *root;
};
typedef struct xmldocument XMLDocument;

/**
 * MES FONCTIONS
 */
void XMLNodelist_init(XMLNodelist *list)
{
    list->heap_size = 1;
    list->size = 0;
    list->data = (XMLNode **)malloc(sizeof(XMLNode *) * list->heap_size);
}

void XMLNodelist_add(XMLNodelist *list, XMLNode *node)
{
    while (list->size >= list->heap_size)
    {
        list->heap_size *= 2;
        list->data = (XMLNode **)realloc(list->data, sizeof(XMLNode *) * list->heap_size);
    }
    list->data[list->size++] = node;
}


XMLNode *XMLNode_child(XMLNode *parent, int index)
{ 
    return parent->childrens.data[index];
}

void XMLAttribue_free(XMLAttribute *attr)
{
    free(attr->key);
    free(attr->value);
}

void XMLAttributeListe_init(XMLAttributelist *list)
{
    list->heap_size = 1;
    list->size = 0;
    list->data = (XMLAttribute *)malloc(sizeof(XMLAttribute) * list->heap_size);
}

void XMLAttributeList_add(XMLAttributelist *list, XMLAttribute *attr)
{
    while (list->size >= list->heap_size)
    {
        list->heap_size *= 2;
        list->data = (XMLAttribute *)realloc(list->data, sizeof(XMLAttribute) * list->heap_size);
    }
    list->data[list->size++] = *attr;
}

XMLNode *XMLNode_new(XMLNode *parent)
{
    XMLNode *node = (XMLNode *)malloc(sizeof(XMLNode));
    node->parent = parent;
    node->tag = NULL;
    node->inner_text = NULL;
    XMLAttributeListe_init(&node->attributes);
   XMLNodelist_init(&node->childrens);
    if (parent)
        XMLNodelist_add(&parent->childrens, node);
    return node;
}

void XMLNode_free(XMLNode *node)
{
    if (node->tag)
        free(node->tag);
    if (node->inner_text)
        free(node->inner_text);
    for (int i = 0; i < node->attributes.size; i++)
        XMLAttribue_free(&node->attributes.data[i]);
    free(node);
}


int XMLDocument_load(XMLDocument *doc, const char *path)
{
    FILE *file = fopen(path, "r");
    if (!file)
    {
        fprintf(stderr, "ne peut pas ouvrir le fichier Ã  partir de %s !\n", path);
        return FALSE;
    }

    fseek(file, 0, SEEK_END);
    int size = ftell(file);
    fseek(file, 0, SEEK_SET);

    char *buf = (char *)malloc(sizeof(char) * size + 1);
    fread(buf, 1, size, file);
    fclose(file);
    buf[size] = '\0';

    doc->root = XMLNode_new(NULL);

    char lex[256];
    int lexi = 0;
    int i = 0;

    XMLNode *curr_node = NULL;

    while (buf[i] != '\0')
    {
        if (buf[i] == '<')
        {
            lex[lexi] = '\0';

            //inner text
            if (strlen(lex) > 0)
            {
                if (!curr_node)
                {
                    fprintf(stderr, "Text outside of document\n");
                    return FALSE;
                }
                curr_node->inner_text = strdup(lex);
                lexi = 0;
            }

            //end of node
            if (buf[i + 1] == '/')
            {
                i += 2;
                while (buf[i] != '>')
                    lex[lexi++] = buf[i++];

                lex[lexi] = '\0';

                if (!curr_node)
                {
                    fprintf(stderr, "Already at the root\n");
                    return FALSE;
                }

                if (strcmp(curr_node->tag, lex))
                {
                    fprintf(stderr, "Wismached tags (%s != %s)\n ", curr_node->tag, lex);
                    return FALSE;
                }
                curr_node = curr_node->parent;
                i++;
                continue;
            }

            //set current node
            if (!curr_node)
                curr_node = doc->root;
            else
                curr_node = XMLNode_new(curr_node);

            //get the beginning of tag
            i++;
            XMLAttribute curr_attr = {0, 0};
            while (buf[i] != '>')
            {
                lex[lexi++] = buf[i++];

                //tag name
                if (buf[i] == ' ' && !curr_node->tag)
                {
                    lex[lexi] = '\0';
                    curr_node->tag = strdup(lex);
                    lexi = 0;
                    i++;
                    continue;
                }
                //usually ignor spaces
                if (lex[lexi - 1] == ' ')
                {
                    lexi--;
                    continue;
                }

                //Attribute key
                if (buf[i] == '=')
                {
                    lex[lexi] = '\0';
                    curr_attr.key = strdup(lex);
                    lexi = 0;
                    continue;
                }

                //Attribute value
                if (buf[i] == '"')
                {
                    if (!curr_attr.key)
                    {
                        fprintf(stderr, "Value has no key\n");
                        return FALSE;
                    }
                    lexi = 0;
                    i++;

                    while (buf[i] != '"')
                        lex[lexi++] = buf[i++];

                    lex[lexi] = '\0';
                    curr_attr.value = strdup(lex);
                    XMLAttributeList_add(&curr_node->attributes, &curr_attr);
                    curr_attr.key = NULL;
                    curr_attr.value = NULL;
                    lexi = 0;
                    i++;
                    continue;
                }
            }

            // set tag name if none
            lex[lexi] = '\0';

            //reset lexer
            lexi = 0;
            i++;
            continue;
        }
        else
        {
            lex[lexi++] = buf[i++];
        }
    }
    return TRUE;
}

void XMLDocument_free(XMLDocument *Doc)
{
    XMLNode_free(Doc->root);
}

#endif